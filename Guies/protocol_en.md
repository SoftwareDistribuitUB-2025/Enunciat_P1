# Protocol

This section describes the communication protocol established between the game client and the server. The generic format of the messages, as well as the different message codes, are described in [this document](./messages_en.md).

It should be noted that there will be no data persistence on the **server**, so if it is closed and a new server is opened, all game and player information will be lost.

## 1. Starting the game

The game is started by the **client** with a `CREATE` command if they want to create a new game, or with `JOIN` if they want to join an existing game:

`C ------- CREATE (playerName, W, H, T1, T2, T3, T4, T5, AI) ------> S`

`C ------- JOIN (playerName) ------> S`

In this message, the player's name `playerName` is specified, and in case of creating a new game, the game details are included, where `W` and `H` are the board dimensions, and `TN` is the number of ships of type $T_N$ that can be placed. See the description of each parameter in the [game definition](./battleship_en.md). The following table specifies the format of the parameters:

| **Parameter**  | **Type** | **Format**     |
| -------------- | -------- | -------------- |
| playerName     | String   | 50 bytes ASCII |
| W              | Numeric  | 1 byte         |
| H              | Numeric  | 1 byte         |
| $T_1\dots T_5$ | Numeric  | 1 byte         |
| AI             | Boolean  | 1 byte         |

The **server** will respond with an `OK` command, returning a `playerId` that will allow the user to play in this game, and a `gameId` that will allow identifying the game. Both `playerId` and `gameId` will be generated by the server using the `Random()` function, will be five digits long, and cannot start with zero.

`C <------------- OK (playerId, gameId) ------------ S`

| **Parameter** | **Type** | **Format** |
| ------------- | -------- | ---------- |
| playerId      | Numeric  | Int32      |
| gameId        | Numeric  | Int32      |

If for some reason the game cannot be started, the **server** will send an `ERROR` message. Refer to the error message format in [this document](./errors_en.md).

Finally, if for any reason the **client** has disconnected, they can request to rejoin the game they were playing, through a `REJOIN` message. In this case, the server will generate a new `playerId` for the player and respond with the `OK` message as in the previous case. Note that the previously assigned `playerId` will no longer be valid once the new one has been generated.

`C ------- REJOIN (playerName) ------> S`

| **Parameter** | **Type** | **Format**     |
| ------------- | -------- | -------------- |
| playerName    | String   | 50 bytes ASCII |

If the game no longer exists, the **server** will remove the player's name from the list of players, and the player will be able to start new games without receiving an error for a duplicate player name.

Once the game has all the assigned players, the server will notify the **clients** with a `GAMESTATUS` message. This message will include the `gameState`, the player's own board information `board1`, the opponent's board information (whether human or AI) `board2`, and additional information depending on the state of the game.

`C <------------- GAMESTATUS (gameState, boardSize, board1, board2, info) ------------ S`

| **Parameter** | **Type**      | **Format**                                                   |
| ------------- | ------------- | ------------------------------------------------------------ |
| gameState    | Numeric       | 1 byte                                                       |
| boardSize      | Number of board cells | Int32. See [board representation](./board_en.md) |
| board1        | Cells by rows | $W\times H$ bytes. See [board representation](./board_en.md) |
| board2        | Cells by rows | $W\times H$ bytes. See [board representation](./board_en.md) |
| info          | $N$ bytes     | Depends on the state. See the table below                    |

You can find a definition of the different game states in [initial information](./battleship_en.md) and the message format representation according to the game state:

| **gameState**      | **Information**                 | **Type** | **Format** |
| ------------------- | ------------------------------- | -------- | ---------- |
| WAITING_PLAYERS (1) |                                 |          |            |
| SETUP (2)           | Player1 ready (0/1)             | Boolean  | 1 byte     |
|                     | Player2 ready (0/1)             | Boolean  | 1 byte     |
|                     | # Remaining ships of type $T_1$ | Numeric  | 1 byte     |
|                     | # Remaining ships of type $T_2$ | Numeric  | 1 byte     |
|                     | # Remaining ships of type $T_3$ | Numeric  | 1 byte     |
|                     | # Remaining ships of type $T_4$ | Numeric  | 1 byte     |
|                     | # Remaining ships of type $T_5$ | Numeric  | 1 byte     |
| PLAYING (3)         | Turn of Player1 (0/1)           | Boolean  | 1 byte     |
|                     | Turn of Player2 (0/1)           | Boolean  | 1 byte     |
| FINISHED (4)        | Player1 won (0/1)               | Boolean  | 1 byte     |
|                     | Player2 won (0/1)               | Boolean  | 1 byte     |

For example, a `GAMESTATUS` message for a game where the opponent has finished placing their ships, but we still need to place one of type $T_2$ and two of type $T_5$ (we are in the `SETUP` phase) would look like:

| **messageType** | **gameStatus** | **boardSize** | **board1**              | **board2**              | **P1 ready** | **P2 ready** | $\bf{T_1}$ | $\bf{T_2}$ | $\bf{T_3}$ | $\bf{T_4}$ | $\bf{T_5}$ |
| --------------- | -------------- | ----------------------- | ----------------------- | ------------ | ------------ | ---------- | ---------- | ---------- | ---------- | ---------- | -----|
| 9               | 2    |  $W\times H$        | $v_{1,1},\dots,v_{W,H}$ | $v_{1,1},\dots,v_{W,H}$ | 0            | 1            | 0          | 1          | 0          | 0          | 2          |
| <1 byte>        | <1 byte>  | <4 bytes>     | <${W\times H}$ bytes>   | <${W\times H}$ bytes>   | <1 byte>     | <1 byte>     | <1 byte>   | <1 byte>   | <1 byte>   | <1 byte>   | <1 byte>   |

## 2. Game setup

Once a game is started, the first step is to place the ships on the grid. The **client** can query the game configuration with a `GETCONFIG` command, and the **server** will respond with a `GAMECONFIG` message containing the game parameters:

`C ------- GETCONFIG (playerId, gameId) ------> S`

| **Parameter** | **Type** | **Format** |
| ------------- | -------- | ---------- |
| playerId      | Numeric  | Int32      |
| gameId        | Numeric  | Int32      |

`C <------------- GAMECONFIG (W, H, T1, T2, T3, T4, T5) ------------ S`

| **Parameter**  | **Type** | **Format** |
| -------------- | -------- | ---------- |
| W              | Numeric  | 1 byte     |
| H              | Numeric  | 1 byte     |
| $T_1\dots T_5$ | Numeric  | 1 byte     |

Note that $T_i$ corresponds to the number of ships of type $T_i$ that can be placed.

The **client** will add the different ships by sending `ADDVESSEL` messages to the **server**. Along with the player and game identifiers, the ship type **type** (value from 1 to 5), the initial row and column **(ri, ci)**, and the final row and column **(rf, cf)** will be provided. Both row and column are numbered starting from $1$.

The server will respond with `OK` messages if the ship was added correctly or `ERROR` if there is an error.

`C ------- ADDVESSEL (playerId, gameId, type, ri, ci, rf, cf) ------> S`

| **Parameter** | **Type** | **Format** |
| ------------- | -------- | ---------- |
| playerId      | Numeric  | Int32      |
| gameId        | Numeric  | Int32      |
| type          | Numeric  | 1 byte     |
| ri            | Numeric  | 1 byte     |
| ci            | Numeric  | 1 byte     |
| rf            | Numeric  | 1 byte     |
| cf            | Numeric  | 1 byte     |

## 3. Playing the game

Once the setup is complete, the game can begin. The **client** makes a move by shooting (`SHOT`) at a cell $(r, c)$ on the opponent's board:

`C ------- SHOT (playerId, gameId, r, c) ------> S`

| **Parameter** | **Type** | **Format** |
| ------------- | -------- | ---------- |
| playerId      | Numeric  | Int32      |
| gameId        | Numeric  | Int32      |
| r             | Numeric  | 1 byte     |
| c             | Numeric  | 1 byte     |

If everything goes well, the **server** will respond with a `HIT` or `FAIL` message depending on whether there was a ship at the cell $(r,c)$ or not. Additionally, if it's a `HIT`, a `Sink` parameter will indicate if it was the last remaining position of the ship and it has been sunk or not. In case of error, a `ERROR` message will be returned.

`C <------------- HIT (Sink) ------------ S`

`C <------------- FAIL ------------ S`

| **Parameter** | **Type** | **Format** |
| ------------- | -------- | ---------- |
| Sink          | Boolean  | 1 byte     |

Once the move has been processed, the server will send us a `GAMESTATUS` message. The options are that we can continue playing (in case of a `HIT`), that the opponent has made a move in the case of a `FAIL`, or in either case, that the game has finished.

At any time, a **client** can leave a game. They will do this by sending a `LEAVE` message to the **server**.

`C ------- LEAVE (playerId, gameId) ------> S`

The server will respond with an `OK` message if everything went well, or with an `ERROR`. Once the game is abandoned, we will no longer have access to the results or be able to interact with it.

Finally, the client can always request the current status of the game by sending a `GETSTATUS` message.

`C ------- GETSTATUS (playerId, gameId) ------> S`

The server will respond with a `GAMESTATUS` message.
